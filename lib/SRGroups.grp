#
# SRGroups: Self-replicating groups of regular rooted trees.
#
# Routines
#

InstallGlobalFunction(SRGroup,function(k,n,num)
	return AllSRGroups(Degree,k,Level,n,Number,num);
end);


InstallGlobalFunction(AllSRGroups,function(arg)
	local groupList, groupNames, k, n, num, inputArgs, i;
	
	inputArgs:=[];

	if IsInt(Position(arg,Degree)) then
		Add(inputArgs,arg[Position(arg,Degree)+1]);
		k:=arg[Position(arg,Degree)+1];
	else
		Add(inputArgs,0);
	fi;
	
	if IsInt(Position(arg,Depth)) or IsInt(Position(arg,Level)) then
		if IsInt(Position(arg,Depth)) then
			Add(inputArgs,arg[Position(arg,Depth)+1]);
			n:=arg[Position(arg,Depth)+1];
		elif IsInt(Position(arg,Level)) then
			Add(inputArgs,arg[Position(arg,Level)+1]);
			n:=arg[Position(arg,Level)+1];
		fi;
	else
		Add(inputArgs,0);
	fi;
	
	if IsInt(Position(arg,Number)) then
		Add(inputArgs,arg[Position(arg,Number)+1]);
		num:=arg[Position(arg,Number)+1];
	else
		Add(inputArgs,0);
	fi;
	
	if IsInt(Position(arg,Projection)) then
		Add(inputArgs,arg[Position(arg,Projection)+1]);
	else
		Add(inputArgs,0);
	fi;
	
	if IsInt(Position(arg,IsSubgroup)) then
		Add(inputArgs,arg[Position(arg,IsSubgroup)+1]);
	else
		Add(inputArgs,0);
	fi;
	
	if IsInt(Position(arg,Size)) then
		Add(inputArgs,arg[Position(arg,Size)+1]);
	else
		Add(inputArgs,0);
	fi;
	
	if IsInt(Position(arg,NumberOfGenerators)) then
		Add(inputArgs,arg[Position(arg,NumberOfGenerators)+1]);
	else
		Add(inputArgs,0);
	fi;
	
	Add(inputArgs,1);
	
	if IsInt(Position(arg,IsAbelian)) then
		Add(inputArgs,arg[Position(arg,IsAbelian)+1]);
	else
		Add(inputArgs,0);
	fi;
	
	groupList:=CallFuncList(SRGroupsInfo,inputArgs);
	inputArgs[Length(inputArgs)-1]:=2;
	groupNames:=CallFuncList(SRGroupsInfo,inputArgs);
	if IsBound(num) then
		groupList:=RegularRootedTreeGroup(k,n,Group(groupList));
		SetName(groupList,groupNames);
	else
		if IsBound(k) then
			if IsBound(n) then
				Apply(groupList,G->RegularRootedTreeGroup(k,n,Group(G)));
			else
				Apply(groupList,G->RegularRootedTreeGroup(k,EvalString(SplitString(groupNames[Position(groupList,G)],",")[2]),Group(G)));
			fi;
		else
			if IsBound(n) then
				Apply(groupList,G->RegularRootedTreeGroup( EvalString(SplitString(SplitString(groupNames[Position(groupList,G)],",")[1],"(")[2]),n,Group(G)));
			else
				Apply(groupList,G->RegularRootedTreeGroup( EvalString(SplitString(SplitString(groupNames[Position(groupList,G)],",")[1],"(")[2]),EvalString(SplitString(groupNames[Position(groupList,G)],",")[2]),Group(G)));
			fi;
		fi;
		for i in [1..Length(groupList)] do
			SetName(groupList[i],groupNames[i]);
		od;
	fi;
	
	return groupList;
end);

# arg[1]:=degree (int > 1)
# arg[2]:=depth (int > 0)
# arg[3]:=number (int > 0)
# arg[4]:=groups with same projection (integer; arg[3]=0 is required)
# arg[5]:=subgroups of group (integer; arg[3])
# arg[6]:=size (int >= degree^depth) (arg[3]=0 is required)
# arg[7]:=smallest number of generators (int >= 1)
# arg[7]:=position/index (integer; one of arg[3]=0 or arg[4]=0 is required)
# arg[8]:=abelian check (boolean)
# All arguments can be set to 0 to ignore them.
InstallGlobalFunction(SRGroupsInfo,function(arg)
	local dir, fnam, G, list, listTemp, i, j, Gpos, last, zeros, srDegrees, srLevels;
	
	zeros:=Positions(arg,0);
	last:=0;
	for i in [1..Length(arg)] do
		if IsInt(arg[i]) and (not arg[i]=0) then
			last:=i;
		fi;
	od;

	dir:= DirectoriesPackageLibrary( "SRGroups", "data" );
	if (1 in zeros and (not 2 in zeros)) then
		srDegrees:=DuplicateFreeList(SRDegrees());
		list:=[];
		if not IsEmpty(srDegrees) then
			for i in [1..Length(srDegrees)] do
				if IsExistingFile(Filename( dir[1], Concatenation("sr_",String(srDegrees[i]),"_",String(arg[2]),".grp"))) then
					fnam:=Filename( dir[1], Concatenation("sr_",String(srDegrees[i]),"_",String(arg[2]),".grp"));
					Read(fnam);
					listTemp:=EvalString(Concatenation("sr_",String(srDegrees[i]),"_",String(arg[2])));
					Append(list,listTemp);
					MakeReadWriteGlobal(Concatenation("sr_",String(srDegrees[i]),"_",String(arg[2])));
					UnbindGlobal(Concatenation("sr_",String(srDegrees[i]),"_",String(arg[2])));
				fi;
			od;
			if IsEmpty(list) then
				Print("These groups are not available (yet)!");
				return;
			fi;
		else
			Print("These groups are not available (yet)!");
			return;
		fi;
	elif ((not 1 in zeros) and 2 in zeros) then
		srLevels:=SRLevels(arg[1]);
		list:=[];
		if not IsEmpty(srLevels) then
			for i in [1..Length(srLevels)] do
				fnam:=Filename( dir[1], Concatenation("sr_",String(arg[1]),"_",String(srLevels[i]),".grp"));
				Read(fnam);
				listTemp:=EvalString(Concatenation("sr_",String(arg[1]),"_",String(srLevels[i])));
				Append(list,listTemp);
				MakeReadWriteGlobal(Concatenation("sr_",String(arg[1]),"_",String(srLevels[i])));
				UnbindGlobal(Concatenation("sr_",String(arg[1]),"_",String(srLevels[i])));
			od;
		else
			Print("These groups are not available (yet)!");
			return;
		fi;
	elif (1 in zeros and 2 in zeros) then
		srDegrees:=DuplicateFreeList(SRDegrees());
		if IsEmpty(srDegrees) then
			for i in [1..Length(srDegrees)] do
				srLevels:=SRLevels(srDegrees[i]);
				for j in [1..Length(srLevels)] do
					fnam:=Filename( dir[1], Concatenation("sr_",String(srDegrees[i]),"_",String(srLevels[j]),".grp"));
					Read(fnam);
					listTemp:=EvalString(Concatenation("sr_",String(srDegrees[i]),"_",String(srLevels[j])));
					Append(list,listTemp);
					MakeReadWriteGlobal(Concatenation("sr_",String(srDegrees[i]),"_",String(srLevels[j])));
					UnbindGlobal(Concatenation("sr_",String(srDegrees[i]),"_",String(srLevels[j])));
				od;
			od;
		else
			Print("These groups are not available (yet)!");
			return;
		fi;
	else
		if IsExistingFile(Filename( dir[1], Concatenation("sr_",String(arg[1]),"_",String(arg[2]),".grp"))) then
			fnam:=Filename( dir[1], Concatenation("sr_",String(arg[1]),"_",String(arg[2]),".grp"));
			Read(fnam);
			list:=EvalString(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
			MakeReadWriteGlobal(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
			UnbindGlobal(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
		else
			Print("These groups are not available (yet)!");
			return;
		fi;
	fi;
	
	if Length(arg)>=9 and (not 9 in zeros) then
		listTemp:=[];
		for i in [1..Length(list)] do
			if IsAbelian(Group(list[i][1]))=arg[9] then
				Add(listTemp,list[i]);
			fi;
		od;
		list:=listTemp;
	fi;
	
	if Length(arg)>=1 and (last=2 or last=1) then
		G:=list;
		return G;
	fi;
	
	if Length(arg)>=3 and (not 3 in zeros) then
		if not (1 in zeros or 2 in zeros) then
			list:=list[arg[3]];
		else
			Gpos:=1;
			listTemp:=[];
			for i in [1..Length(list)] do
				if EndsWith(list[i][2],Concatenation(",",String(arg[3]),")")) then
					listTemp[Gpos]:=list[i];
					Gpos:=Gpos+1;
				fi;
			od;
			list:=listTemp;
		fi;
		if last=3 then
			G:=list;
			return G;
		fi;
	fi;
	
	if (Length(arg)>=4 and 3 in zeros and (not (1 in zeros or 2 in zeros)) and (not 4 in zeros)) then
		Gpos:=1;
		listTemp:=[];
		for i in [1..Length(list)] do
			if EndsWith(list[i][3],Concatenation(",",String(arg[4]),")")) then
				listTemp[Gpos]:=list[i];
				Gpos:=Gpos+1;
			fi;
		od;
		list:=listTemp;
		if last=4 then
			G:=list;
			return G;
		fi;
	fi;
	
	if (Length(arg)>=5 and 3 in zeros and (not (1 in zeros or 2 in zeros)) and (not 5 in zeros)) then
		Gpos:=1;
		listTemp:=[];
		for i in [1..Length(list)] do
			if IsSubgroup(Group(list[arg[5]][1]),Group(list[i][1])) and (not i=arg[5]) then
				listTemp[Gpos]:=list[i];
				Gpos:=Gpos+1;
			fi;
		od;
		list:=listTemp;
		if last=5 then
			G:=list;
			return G;
		fi;
	fi;
	
	if Length(arg)>=6 and 3 in zeros and 7 in zeros and (not 6 in zeros) then
		listTemp:=[];
		for i in [1..Length(list)] do
			if Size(Group(list[i][1]))=arg[6] then
				Add(listTemp,list[i]);
			fi;
		od;
		list:=listTemp;
		if last=6 then
			G:=list;
			return G;
		fi;
	fi;
	
	if Length(arg)>=7 and 3 in zeros and 6 in zeros and (not 7 in zeros) then
		listTemp:=[];
		for i in [1..Length(list)] do
			if Length(MinimalGeneratingSet(Group(list[i][1])))=arg[7] then
				Add(listTemp,list[i]);
			fi;
		od;
		list:=listTemp;
		if last=7 then
			G:=list;
			return G;
		fi;
	fi;

	if (Length(arg)>=8 and (3 in zeros or 4 in zeros) and (not 8 in zeros)) then
		listTemp:=[];
		if 3 in zeros then
			for i in [1..Length(list)] do
				listTemp[i]:=list[i][arg[8]];
			od;
		else
			listTemp:=list[arg[8]];
		fi;
		list:=listTemp;
		if last=8 then
			G:=list;
			return G;
		fi;
	fi;

	if IsBound(G) then
		return G;
	else
		Print("No method exists!");
		return;
	fi;
end);

InstallGlobalFunction(AllSRGroupsInfo,function(arg)
	local inputArgs;

	inputArgs:=[];

	if IsInt(Position(arg,Degree)) then
		Add(inputArgs,arg[Position(arg,Degree)+1]);
	else
		Add(inputArgs,0);
	fi;
	
	if IsInt(Position(arg,Depth)) or IsInt(Position(arg,Level)) then
		if IsInt(Position(arg,Depth)) then
			Add(inputArgs,arg[Position(arg,Depth)+1]);
		elif IsInt(Position(arg,Level)) then
			Add(inputArgs,arg[Position(arg,Level)+1]);
		fi;
	else
		Add(inputArgs,0);
	fi;
	
	if IsInt(Position(arg,Number)) then
		Add(inputArgs,arg[Position(arg,Number)+1]);
	else
		Add(inputArgs,0);
	fi;
	
	if IsInt(Position(arg,Projection)) then
		Add(inputArgs,arg[Position(arg,Projection)+1]);
	else
		Add(inputArgs,0);
	fi;
	
	if IsInt(Position(arg,IsSubgroup)) then
		Add(inputArgs,arg[Position(arg,IsSubgroup)+1]);
	else
		Add(inputArgs,0);
	fi;
	
	if IsInt(Position(arg,Size)) then
		Add(inputArgs,arg[Position(arg,Size)+1]);
	else
		Add(inputArgs,0);
	fi;
	
	if IsInt(Position(arg,NumberOfGenerators)) then
		Add(inputArgs,arg[Position(arg,NumberOfGenerators)+1]);
	else
		Add(inputArgs,0);
	fi;
	
	if IsInt(Position(arg,Index)) or IsInt(Position(arg,Position)) then
		if IsInt(Position(arg,Index)) then
			Add(inputArgs,arg[Position(arg,Index)+1]);
		elif IsInt(Position(arg,Position)) then
			Add(inputArgs,arg[Position(arg,Position)+1]);
		fi;
	else
		Add(inputArgs,0);
	fi;
	
	if IsInt(Position(arg,IsAbelian)) then
		Add(inputArgs,arg[Position(arg,IsAbelian)+1]);
	else
		Add(inputArgs,0);
	fi;

	return CallFuncList(SRGroupsInfo,inputArgs);
end);

InstallGlobalFunction(CheckSRProjections,function(arg)
	local dir, fnam, list1, list2, pr, i, G1, G2, check, aut, autAbove;

	check:=0;
	aut:=AutT(arg[1],arg[2]);
	autAbove:=AutT(arg[1],arg[2]-1);
	list1:=AllSRGroups(Degree,arg[1],Depth,arg[2]);
	list2:=AllSRGroupsInfo(Degree,arg[1],Depth,arg[2],Position,3);
	pr:=Projection(aut);
	for i in [1..Length(list1)] do
		G1:=Image(pr,list1[i]);
		G2:=Group(EvalString(Concatenation("SRGroupsInfo(",SplitString(list2[i],"(")[2]))[1]);
		if not (G1=G2 or IsConjugate(autAbove,G1,G2)) then
			Print("SRGroup(",String(arg[1]),",",String(arg[2]),")[",String(i),"]\n");
			check:=check+1;
		fi;
	od;

	if check=0 then
		Print("All groups project correctly.");
	else
		Print(check," groups did not project corrrectly.");
	fi;

	return;
end);

InstallGlobalFunction(StringVariables, function(arg)
	local Superstring, i;

	for i in [1..Length(arg)] do
		if i=1 then
			Superstring:=Concatenation("varArg",String(i),":=",String(arg[i]),";");
		else
			Superstring:=Concatenation(Superstring,"\nvarArg",String(i),":=",String(arg[i]),";");
		fi;
	od;

	return Superstring;
end);

InstallGlobalFunction(UnbindVariables, function(arg)
	local k;

	for k in [1..Length(arg)] do
		UnbindGlobal(arg[k]);
	od;
	
	return;
end);

InstallGlobalFunction(SRDegrees,function()
	local srDegrees, count, dirData, dataContents;

	dirData:=DirectoriesPackageLibrary("SRGroups", "data");
	dataContents:=DirectoryContents(dirData[1]);

	srDegrees:=[];
	for count in [1..Length(dataContents)] do
		if StartsWith(dataContents[count],"sr_") then
			Add(srDegrees,EvalString(SplitString(dataContents[count], ".", "_")[2]));
		fi;
	od;
	srDegrees:=DuplicateFreeList(srDegrees);
	StableSort(srDegrees);
	return srDegrees;
end);

InstallGlobalFunction(SRLevels,function(deg)
	local srLevels, count, dirData, dataContents;

	dirData:=DirectoriesPackageLibrary("SRGroups", "data");
	dataContents:=DirectoryContents(dirData[1]);

	srLevels:=[];
	for count in [1..Length(dataContents)] do
		if StartsWith(dataContents[count],Concatenation("sr_",String(deg))) then
			Add(srLevels,EvalString(SplitString(dataContents[count], ".", "_")[3]));
		fi;
	od;
	StableSort(srLevels);
	return srLevels;
end);

InstallGlobalFunction(SRGroupsAvailable,function(deg,lev)
		return (lev in SRLevels(deg) and deg in SRDegrees());
end);