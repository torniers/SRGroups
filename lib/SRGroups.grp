#
# SRGroups: Self-replicating groups of regular rooted trees.
#
# Routines
#

# arg[1]:=degree
# arg[2]:=level
# arg[3]:=number
# arg[4]:=groups with same projection (arg[3]=0 is required)
# arg[5]:=position (arg[3]=0 and arg[4]=0 is required)
InstallGlobalFunction(SRGroup,function(arg)
local dir, fnam, G, list, i, Gpos, temp;

dir:= DirectoriesPackageLibrary( "SRGroups", "data" );
if IsExistingFile(Filename( dir[1], Concatenation("sr_",String(arg[1]),"_",String(arg[2]),".grp"))) then
	fnam:=Filename( dir, Concatenation("sr_",String(arg[1]),"_",String(arg[2]),".grp"));
	Read(fnam);
else
	Print("These groups are not available (yet)!");
	return;
fi;

if (Length(arg)=3) and not (arg[3]=0) then
	G:=EvalString(Concatenation("sr_",String(arg[1]),"_",String(arg[2]),"[",String(arg[3]),"]"));
elif (Length(arg)=2) or (Length(arg)=3 and arg[3]=0) then
	G:=EvalString(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
elif (Length(arg)=4) and (arg[3]=0) then
	list:=EvalString(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
	Gpos:=1;
	G:=[];
	for i in [1..Length(list)] do
		if EndsWith(list[i][3],Concatenation(",",String(arg[4]),")")) then
			G[Gpos]:=list[i];
			Gpos:=Gpos+1;
		fi;
	od;	
elif (Length(arg)=5) and ((arg[4]=0) and (arg[3]=0)) then
	list:=EvalString(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
		Gpos:=1;
		G:=[];
		temp:=arg[5];
		for i in [1..Length(list)] do
			G[Gpos]:=list[i][temp];
			Gpos:=Gpos+1;
		od;
else
	Print("No method exists!");
	return;
fi;

MakeReadWriteGlobal(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
UnbindGlobal(Concatenation("sr_",String(arg[1]),"_",String(arg[2])));
return G;
end);

InstallGlobalFunction(CheckSRProjections,function(arg)
local dir, fnam, list1, list2, pr, i, G1, G2, check;

check:=0;
list1:=SRGroup(arg[1],arg[2],0,0,1);
list2:=SRGroup(arg[1],arg[2],0,0,3);
pr:=Projection(AutT(arg[1],arg[2]));
for i in [1..Length(list1)] do
	G1:=Image(pr,Group(list1[i]));
	G2:=Group(EvalString(list2[i])[1]);
	if not G1=G2 then
		Print("SRGroup(",String(arg[1]),",",String(arg[2]),")[",String(i),"]\n");
		check:=check+1;
	fi;
od;

if check=0 then
	Print("All groups project correctly.");
else
	Print(check,"groups did not project corrrectly.");
fi;

return;
end);
# Input:: Any integer in the range [0,31], which denotes the degree of the regular rooted tree being assessed. If the input is 0 or 1, the degree is chosen to be the lowest degree not stored.
# Output:: The file containing all self-replicating groups of the rooted k-tree at the lowest level not stored.
InstallGlobalFunction(SRGroupFile, function(arg)
local fName, dir, k, i, j, list1, list2, list3, deg, lev, SRG, cmnt, n, fNameTemp, GroupList, initial, previous, temp, tempFile, GroupList2, numberoflists, unsortedlist1, unsortedlist2, sortedlist, PrevPosList, N, M, Identicals, o , p, sortingtemp, total, Vertices, I, J, fNameTemp2, PrevGroupList, newgrouplist, Prev, Post, m, fNameTemp3, fNameTemp4, fNameTemp5, fNameTemp6, reEntry, initialo, initialj, totaltemp, kk, totalsrs, reEntrychecker, jj, listOfGroups, x, y, z, levelOneGroups, prePosList, sortedList1, unsortedList1, unsortedList2, repeats, initialz, dir2, fName2, tempfileexist;

# 0. Create directories to be used (dir: storage of final group files, dir2: storage of temporary files).
dir:=DirectoriesPackageLibrary("SRGroups", "data");
dir2:=DirectoriesPackageLibrary("SRGroups", "data/temp_files");
list1:=DirectoryContents(dir[1]); # Creates a list of strings with names of the files/folders stored in dir.

# 1. First check if the input argument is 0 or 1. If so, the tree level is automatically set to 1.
if arg[1]=0 or arg[1]=1 then
	# 1.1. Find the last file with "sr_" in the prefix of the filename, and store it in list2.
	#################### Fix #####################
	totalsrs:=0;
	for k in [1..Length(list1)] do
		if StartsWith(list1[k],"sr_") then
			Add(list2,list1[k]);
		fi;
	od;
	k:=list2[Length(list2)]; # The last entry in list2 will have the highest degree filename string which is consecutive from 2.
	i:=SplitString(k, ".", "_");
	# 1.1.1. Set the degree=deg to be 1 higher than the highest degree stored.
	deg:=EvalString(i[2])+1;
	
	# 1.2. Create required filenames.
	fName:=Filename(dir[1], Concatenation(i[1], "_", String(deg), "_1.grp"));
	fNameTemp3:=Filename(dir2[1],Concatenation("temp_",String(deg),"_1_indiv.grp"));
	fNameTemp4:=Filename(dir2[1],Concatenation("temp_",String(deg),"_1_full.grp"));
	fNameTemp5:=Filename(dir2[1],Concatenation("temp_",String(deg),"_1_var.grp"));
	# 1.2.1. Check if the group files have already been partially created (re-entry condition). If so, read these files to continue from the previous save-point.
	if IsExistingFile(fNameTemp4) and IsExistingFile(fNameTemp5) then
			reEntry:=true;
			reEntrychecker:=true;
			Read(fNameTemp5);
			initialj:=EvalString("varArg1");
	else
		reEntry:=false;
		reEntrychecker:=false;
		initialj:=1;
	fi;
	
	# 1.3. Evaluate all transitive groups of the degree=deg and store their information.
	# Formatting of the group information is also completed here. For degree>1, this is done separately. See any "sr_deg_lev.grp" file for how this formatting is done.
	GroupList:=[];
	for j in [initialj..NrTransitiveGroups(deg)] do
		# 1.3.1. Create entries containing individual group information.
		GroupList[j]:=[];
		GroupList[j][1]:=ShallowCopy(TRANSGrp(deg,j));
		Remove(GroupList[j][1],Length(GroupList[j][1]));
		GroupList[j][2]:=Concatenation("\"SRGroup(",String(deg),",1,",String(j),")\"");
		GroupList[j][3]:="\"emptyset\"";
		GroupList[j][4]:="[\"the classes it extends to\"]";
		# 1.3.2. Print all individual group information (in correct format) to "temp_deg_1_indiv.grp".
		if not j=1 then
			PrintTo(fNameTemp3,Concatenation("\n\n\t[\n\t\t",String(GroupList[j][1])));
		else
			PrintTo(fNameTemp3,Concatenation("\n\t[\n\t\t",String(GroupList[j][1])));
		fi;
		AppendTo(fNameTemp3,",\n\t\t",GroupList[j][2]);
		AppendTo(fNameTemp3,",\n\t\t",GroupList[j][3]);
		if not j=NrTransitiveGroups(deg) then
			AppendTo(fNameTemp3,",\n\t\t",GroupList[j][4],"\n\t],");
		else
			AppendTo(fNameTemp3,",\n\t\t",GroupList[j][4],"\n\t]");
		fi;
		if not IsExistingFile(fNameTemp4) then
			PrintTo(fNameTemp4, Concatenation("##This contains a list of the self-replicating groups on the rooted regular-", String(deg), " tree on level 1 ##\n\nBindGlobal(\"sr_",String(deg),"_1\",\n[")); #################### Fix #####################
		fi;
		# 1.3.3. Print formatted individual group information to "temp_deg_1_full.grp" and save this point.
		AppendTo(fNameTemp4,StringFile(fNameTemp3));
		PrintTo(fNameTemp5,EnString(j)); # Save-point
	od;
	AppendTo(fNameTemp4,"\n]);");
	
	# 1.4. Print all group information to final "sr_deg_1.grp" file, remove all associated temporary files, and unbind all residual variables.
	PrintTo(fName, StringFile(fNameTemp4));
	RemoveFile(fNameTemp3);
	RemoveFile(fNameTemp4);
	RemoveFile(fNameTemp5);
	if reEntrychecker then
		Unleash("varArg1");
	fi;
	
# 2. Case where the input argument is in [2,32].
else 
	# 2.1. Set the degree to be the input argument.
	deg:=arg[1];
	
	# 2.2. Finding the level to begin. If an element of list begins with "sr_arg[1]_", then store it as our value of k. Each time we find another value in list that begins with the same string, overwrite k as the list is sorted in an increasing sequence so naturally it will store the greatest value of k last.
	i:=1;
	k:=0;
	while i < Length(list1)+1 do
		if StartsWith(list1[i], Concatenation("sr_", String(deg))) then
			k:=list1[i];
		fi;
		i:=i+1;
	od;
	if k=0 then 
		lev:=1;
	else
		i:=SplitString(k, ".", "_");
		lev:=EvalString(i[3])+1;
	fi;
	
	# 2.3. Create required filenames.
	fName:=Filename(dir[1], Concatenation("sr_", String(deg), "_", String(lev), ".grp"));
	fName2:=Filename(dir[1],Concatenation("sr_", String(deg), "_", String(lev-1), ".grp"));
	fNameTemp:=Filename(dir2[1], Concatenation("temp_", String(deg), "_", String(lev), ".grp"));
	fNameTemp3:=Filename(dir2[1],Concatenation("temp_",String(deg),"_",String(lev),"_indiv.grp"));
	fNameTemp4:=Filename(dir2[1],Concatenation("temp_",String(deg),"_",String(lev),"_full.grp"));
	fNameTemp5:=Filename(dir2[1],Concatenation("temp_",String(deg),"_",String(lev),"_var.grp"));
	tempfileexist:=false;
	
	# 2.4. Level 1 case.
	if lev=1 then
		# 2.4.1. Check if the group files have already been partially created (re-entry condition). If so, read these files to continue from the previous save point.
		if IsExistingFile(fNameTemp4) and IsExistingFile(fNameTemp5) then
			reEntry:=true;
			reEntrychecker:=true;
			Read(fNameTemp5);
			initialj:=EvalString("varArg1");
		else
			reEntry:=false;
			reEntrychecker:=false;
			initialj:=1;
		fi;
		
		# 2.4.2. Evaluate all transitive groups of the degree=deg and store their information.
		# Formatting of the group information is also completed here. For degree>1, this is done separately. See any "sr_deg_lev.grp" file for how this formatting is done.
		GroupList:=[];
		for j in [initialj..NrTransitiveGroups(deg)] do
			# 2.4.2.1. Create entries containing individual group information.
			GroupList[j]:=[];
			GroupList[j][1]:=ShallowCopy(TRANSGrp(deg,j));
			Remove(GroupList[j][1],Length(GroupList[j][1]));
			GroupList[j][2]:=Concatenation("\"SRGroup(",String(deg),",1,",String(j),")\"");
			GroupList[j][3]:="\"emptyset\"";
			GroupList[j][4]:="[\"the classes it extends to\"]";
			# 2.4.2.2. Print all individual group information (in correct format) to "temp_deg_1_indiv.grp".
			if not j=1 then
				PrintTo(fNameTemp3,Concatenation("\n\n\t[\n\t\t",String(GroupList[j][1])));
			else
				PrintTo(fNameTemp3,Concatenation("\n\t[\n\t\t",String(GroupList[j][1])));
			fi;
			AppendTo(fNameTemp3,",\n\t\t",GroupList[j][2]);
			AppendTo(fNameTemp3,",\n\t\t",GroupList[j][3]);
			if not j=NrTransitiveGroups(deg) then
				AppendTo(fNameTemp3,",\n\t\t",GroupList[j][4],"\n\t],");
			else
				AppendTo(fNameTemp3,",\n\t\t",GroupList[j][4],"\n\t]");
			fi;
			if not IsExistingFile(fNameTemp4) then
				PrintTo(fNameTemp4, Concatenation("##This contains a list of the self-replicating groups on the rooted regular-", String(deg), " tree on level 1 ##\n\nBindGlobal(\"sr_",String(deg),"_1\",\n["));
			fi;
			# 2.4.2.3. Print formatted individual group information to "temp_deg_1_full.grp" and save this point.
			AppendTo(fNameTemp4,StringFile(fNameTemp3));
			PrintTo(fNameTemp5,EnString(j)); # Save-point
		od;
		
	# 2.5. Level>1 case.
	else
		# 2.5.1. Check whether some (or all) groups have already been extended (stored in "temp_deg_lev.grp") and continue from this point.
		initial:=1;
		if IsExistingFile(fNameTemp) then
			# 2.5.1.1. To count the number of stored variables containing the conjugacy class representatives, create a file "temp_deg_lev_check.grp".
			Read(fNameTemp);
			tempFile:=Filename(dir2[1],Concatenation("temp_",String(deg),"_",String(lev),"_check.grp"));
			tempfileexist:=true;
			previous:=0;
			while previous=initial-1 do
				previous:=initial;
				# 2.5.1.2. Print a statement to this file which declares a new variable called initial1, that increments if the variable temp_deg_lev-1_initial_proj exists.
				PrintTo(tempFile,Concatenation("initial1:=",String(initial),";\n\nif IsBound(temp_",String(deg),"_",String(lev-1),"_",String(initial),"_proj) then\n\tinitial1:=initial1+1;\nfi;"));
				Read(tempFile);
				# 2.5.1.3. The variable initial is then incremented by setting its new value to initial1, and loops only if this value increases.
				initial:=EvalString("initial1");
				if previous=initial-1 then
					MakeReadWriteGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(previous),"_proj"));
					UnbindGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(previous),"_proj"));
				fi;
				# 2.5.1.4. Unbind residual variable initial1.
				UnbindGlobal("initial1");
				# 2.5.1.5. The loop won't repeat once it finds an unbound temp_deg_lev-1_initial_proj variable.
			od;
		fi;
		
		# 2.5.2. Extend each group on level lev-1 to all conjugacy class representatives and store their generators.
		list2:=[];
		if initial<=Length(SRGroup(deg,lev-1)) then
			for j in [initial..Length(SRGroup(deg,lev-1))] do
				GroupList:=ConjugacyClassRepsSelfReplicatingSubgroupsWithProjection(deg, lev, Group(SRGroup(deg, lev-1, j)[1]));
				if j=1 then
					AppendTo(fNameTemp,Concatenation("BindGlobal(\"temp_",String(deg),"_",String(lev-1),"_",String(j),"_proj\",\n["));
				else
					AppendTo(fNameTemp,Concatenation("\n\nBindGlobal(\"temp_",String(deg),"_",String(lev-1),"_",String(j),"_proj\",\n["));
				fi;
				for n in [1..Length(GroupList)] do
					list2[n]:=GeneratorsOfGroup(GroupList[n]);
					if n=Length(GroupList) then
						AppendTo(fNameTemp,Concatenation("\n\t",String(list2[n]),"\n]);"));
					else
						AppendTo(fNameTemp,Concatenation("\n\t",String(list2[n]),","));
					fi;
				od;
			od;
		fi;
		
		# 
		fNameTemp2:=Filename(dir2[1],Concatenation("temp_",String(deg),"_",String(lev),"_above_indiv.grp"));
		fNameTemp6:=Filename(dir2[1],Concatenation("temp_",String(deg),"_",String(lev),"_above.grp"));
		GroupList2:=[];
		if lev=2 then
			Read(fNameTemp);
			if IsExistingFile(fNameTemp4) and IsExistingFile(fNameTemp5) then
				reEntry:=true;
				reEntrychecker:=true;
				Read(fNameTemp5);
				initialz:=EvalString("varArg1");
				levelOneGroups:=Length(SRGroup(deg, lev-1));
				newgrouplist:=[];
				repeats:=EvalString("varArg2");
				sortedList1:=EvalString("varArg3");
				unsortedList1:=EvalString("varArg4");
				p:=EvalString("varArg5");
				I:=EvalString("varArg6");
				x:=EvalString("varArg7");
				y:=EvalString("varArg8");
				PrevGroupList:=SRGroup(deg,lev-1);
				PrevPosList:=EvalString("varArg9");
				Vertices:=EvalString("varArg10");
				totaltemp:=0;
				if y>1 then
					for k in [1..y-1] do
					MakeReadWriteGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(PrevPosList[k]),"_proj"));
					UnbindGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(PrevPosList[k]),"_proj"));
					od;
				fi;
			else
				reEntry:=false;
				reEntrychecker:=false;
				unsortedList1:=[];
				sortedList1:=[];
				PrevPosList:=[];
				levelOneGroups:=Length(SRGroup(deg, lev-1));
				PrevGroupList:=SRGroup(deg,lev-1);
				newgrouplist:=[];
				for j in [1..levelOneGroups] do
					unsortedList1[j]:=Length(EvalString(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(j),"_proj")));
				od;
				sortedList1:=SortedList(unsortedList1);
				y:=1;
				x:=1;
				I:=1;
				initialz:=1;
				Vertices:=Length(PrevGroupList);
			fi;
			while y<=levelOneGroups do
				repeats:=Positions(unsortedList1, sortedList1[y]);
				for z in [initialz..Length(repeats)] do
					if not reEntry then
						PrevPosList[y]:=repeats[z];
						p:=1;
					fi;
					while p<=sortedList1[y] do
						GroupList2[x]:=[];
						GroupList2[x][1]:=EvalString(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(PrevPosList[y]),"_proj"))[p];
						GroupList2[x][2]:=Concatenation("\"SRGroup(",String(deg),",",String(lev),",",String(x),")\"");
						GroupList2[x][3]:=Concatenation("\"SRGroup(",String(deg),",",String(lev-1),",",String(y),")\"");
						GroupList2[x][4]:="[\"the classes it extends to\"]";
						if not x=1 then
							PrintTo(fNameTemp3,Concatenation("\n\n\t[\n\t\t",String(GroupList2[x][1])));
						else
							PrintTo(fNameTemp3,Concatenation("\n\t[\n\t\t",String(GroupList2[x][1])));
						fi;
						AppendTo(fNameTemp3,",\n\t\t",GroupList2[x][2]);
						AppendTo(fNameTemp3,",\n\t\t",GroupList2[x][3]);
						if not x=Sum(unsortedList1) then
							AppendTo(fNameTemp3,",\n\t\t",GroupList2[x][4],"\n\t],");
						else
							AppendTo(fNameTemp3,",\n\t\t",GroupList2[x][4],"\n\t]");
						fi;
						if not IsExistingFile(fNameTemp4) then
							PrintTo(fNameTemp4, Concatenation("##This contains a list of the self-replicating groups on the rooted regular-", String(deg), " tree on level", " ", String(lev), "##\n\nBindGlobal(\"sr_",String(deg),"_",String(lev),"\",\n["));
						fi;
						AppendTo(fNameTemp4,StringFile(fNameTemp3));
						PrintTo(fNameTemp5,EnString(z, repeats, sortedList1, unsortedList1, p, I, x, y, PrevPosList, Vertices));
						if reEntry then
							reEntry:=false;
							initialz:=1;
						fi;
						p:=p+1;
						x:=x+1;
					od;
					if not I=x then
						newgrouplist[y]:=PrevGroupList[PrevPosList[y]];
						newgrouplist[y][2]:=String(Concatenation("\"SRGroup(", String(deg), ",", String(lev-1), ",", String(y), ")\""));
						PrintTo(fNameTemp2, "\n\t", "[");
						AppendTo(fNameTemp2, "\n\t\t", newgrouplist[y][1], ",");
						AppendTo(fNameTemp2, "\n\t\t", "", newgrouplist[y][2], ",");
						AppendTo(fNameTemp2, "\n\t\t", "\"", newgrouplist[y][3], "\",");
						for m in [1..sortedList1[y]] do
							newgrouplist[y][4]:=Concatenation("\"SRGroup(",String(deg),",",String(lev),",",String(I),")\"");
							if sortedList1[y]=1 then
								AppendTo(fNameTemp2,"\n\t\t", "[", newgrouplist[y][4], "]\n\t]");
							elif m=1 then
								AppendTo(fNameTemp2, "\n\t\t", "[", newgrouplist[y][4], ",");
							elif m=sortedList1[y] then
								AppendTo(fNameTemp2, "\n\t\t", newgrouplist[y][4], "]\n\t]");
							else 
								AppendTo(fNameTemp2, "\n\t\t", newgrouplist[y][4], ",");
							fi;
							I:=I+1;
						od;
						MakeReadWriteGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(PrevPosList[y]),"_proj"));
						UnbindGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(PrevPosList[y]),"_proj"));
						Vertices:=Vertices-1;
						if not IsExistingFile(fNameTemp6) then
							PrintTo(fNameTemp6, Concatenation("##This contains a list of the self-replicating groups on the rooted regular-", String(deg), " tree on level", " ", String(lev-1), "##\n\nBindGlobal(\"sr_",String(deg),"_",String(lev-1),"\",\n["));
						fi;
						if Vertices = 0 then
							AppendTo(fNameTemp6,StringFile(fNameTemp2),"\n]);");
						else
							AppendTo(fNameTemp6,StringFile(fNameTemp2),",\n");
						fi;
						PrintTo(fNameTemp5,EnString(z, repeats, sortedList1, unsortedList1, p, I, x, y, PrevPosList, Vertices));
						if reEntry then
							reEntry:=false;
							initialz:=1;
						fi;
					fi;
					if reEntry then
						reEntry:=false;
						initialz:=1;
					fi;
					y:=y+1;
				od;
			od;
		else 
			numberoflists:=Length(SRGroup(deg,lev-2));
			Read(fNameTemp);
			if IsExistingFile(fNameTemp4) and IsExistingFile(fNameTemp5) then
				reEntry:=true;
				reEntrychecker:=true;
				Read(fNameTemp5);
				initialj:=EvalString("varArg1");
				initialo:=EvalString("varArg2");
				newgrouplist:=[];
				sortedlist:=EvalString("varArg3");
				total:=EvalString("varArg4");
				unsortedlist1:=EvalString("varArg5");
				unsortedlist2:=EvalString("varArg6");
				n:=EvalString("varArg7");
				p:=EvalString("varArg8");
				I:=EvalString("varArg9");
				M:=EvalString("varArg10");
				N:=EvalString("varArg11");
				Identicals:=EvalString("varArg12");
				PrevGroupList:=SRGroup(deg,lev-1);
				PrevPosList:=EvalString("varArg13");
				Vertices:=EvalString("varArg14");
				totaltemp:=0;
				for j in [1..initialj] do
					if j=initialj then
						for k in [1..n-1] do
							MakeReadWriteGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(total+PrevPosList[j][k]),"_proj"));
							UnbindGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(total+PrevPosList[j][k]),"_proj"));
						od;
					else
						if j>1 then
							for kk in [1..j-1] do
								totaltemp:=totaltemp+Length(unsortedlist2[kk]);
							od;
						fi;
						for k in [1..Length(unsortedlist2[j])] do
							MakeReadWriteGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(totaltemp+PrevPosList[j][k]),"_proj"));
							UnbindGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(totaltemp+PrevPosList[j][k]),"_proj"));
						od;
					fi;
				od;
			else
				reEntry:=false;
				reEntrychecker:=false;
				unsortedlist1:=[];
				for j in [1..Length(SRGroup(deg,lev-1))] do
					unsortedlist1[j]:=Length(EvalString(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(j),"_proj")));
				od;
				unsortedlist2:=[];
				sortedlist:=[];
				PrevPosList:=[];
				PrevGroupList:=SRGroup(deg,lev-1);
				newgrouplist:=[];
				Vertices:=Length(PrevGroupList);
				total:=0;
				N:=1;
				M:=1;
				I:=1;
				J:=1;
				initialj:=1;
				initialo:=1;
			fi;
			for j in [initialj..numberoflists] do
				newgrouplist[j]:=[];
				if not reEntry then
					unsortedlist2[j]:=[];
					sortedlist[j]:=[];
					PrevPosList[j]:=[];
					if j>1 then
						total:=total+Length(SRGroup(deg,lev-1,0,j-1));
					fi;
					for n in [1..Length(SRGroup(deg,lev-1,0,j))] do
						unsortedlist2[j][n]:=unsortedlist1[N];
						N:=N+1;
					od;
					n:=1;
					sortedlist[j]:=SortedList(unsortedlist2[j]);
				fi;
				while n<=Length(SRGroup(deg,lev-1,0,j)) do
					if not reEntry then
						Identicals:=Positions(unsortedlist2[j],sortedlist[j][n]);
					fi;
					for o in [initialo..Length(Identicals)] do
						if not reEntry then
							PrevPosList[j][n]:=Identicals[o];
							p:=1;
						fi;
						while p<=sortedlist[j][n] do
							GroupList2[M]:=[];
							GroupList2[M][1]:=EvalString(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(total+PrevPosList[j][n]),"_proj"))[p];
							GroupList2[M][2]:=Concatenation("\"SRGroup(",String(deg),",",String(lev),",",String(M),")\"");
							GroupList2[M][3]:=Concatenation("\"SRGroup(",String(deg),",",String(lev-1),",",String(total+n),")\"");
							GroupList2[M][4]:="[\"the classes it extends to\"]";
							if not M=1 then
								PrintTo(fNameTemp3,Concatenation("\n\n\t[\n\t\t",String(GroupList2[M][1])));
							else
								PrintTo(fNameTemp3,Concatenation("\n\t[\n\t\t",String(GroupList2[M][1])));
							fi;
							AppendTo(fNameTemp3,",\n\t\t",GroupList2[M][2]);
							AppendTo(fNameTemp3,",\n\t\t",GroupList2[M][3]);
							if not M=Sum(unsortedlist1) then
								AppendTo(fNameTemp3,",\n\t\t",GroupList2[M][4],"\n\t],");
							else
								AppendTo(fNameTemp3,",\n\t\t",GroupList2[M][4],"\n\t]");
							fi;
							if not IsExistingFile(fNameTemp4) then
								PrintTo(fNameTemp4, Concatenation("##This contains a list of the self-replicating groups on the rooted regular-", String(deg), " tree on level", " ", String(lev), "##\n\nBindGlobal(\"sr_",String(deg),"_",String(lev),"\",\n["));
							fi;
							AppendTo(fNameTemp4,StringFile(fNameTemp3));
							PrintTo(fNameTemp5,EnString(j, o, sortedlist, total, unsortedlist1, unsortedlist2, n, p, I, M, N, Identicals, PrevPosList, Vertices));
							if reEntry then
								reEntry:=false;
								initialo:=1;
							fi;
							p:=p+1;
							M:=M+1;
						od;
						if not I=M then
							newgrouplist[j][n]:=PrevGroupList[total+PrevPosList[j][n]];
							newgrouplist[j][n][2]:=String(Concatenation("\"SRGroup(", String(deg), ",", String(lev-1), ",", String(total+n), ")\""));
							PrintTo(fNameTemp2, "\n\t", "[");
							AppendTo(fNameTemp2, "\n\t\t", newgrouplist[j][n][1], ",");
							AppendTo(fNameTemp2, "\n\t\t", "", newgrouplist[j][n][2], ",");
							AppendTo(fNameTemp2, "\n\t\t", "\"", newgrouplist[j][n][3], "\",");
							for m in [1..sortedlist[j][n]] do
								newgrouplist[j][n][4]:=Concatenation("\"SRGroup(",String(deg),",",String(lev),",",String(I),")\"");
								if sortedlist[j][n]=1 then
									AppendTo(fNameTemp2,"\n\t\t", "[", newgrouplist[j][n][4], "]\n\t]");
								elif m=1 then
									AppendTo(fNameTemp2, "\n\t\t", "[", newgrouplist[j][n][4], ",");
								elif m=sortedlist[j][n] then
									AppendTo(fNameTemp2, "\n\t\t", newgrouplist[j][n][4], "]\n\t]");
								else 
									AppendTo(fNameTemp2, "\n\t\t", newgrouplist[j][n][4], ",");
								fi;
								I:=I+1;
							od;
							MakeReadWriteGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(total+PrevPosList[j][n]),"_proj"));
							UnbindGlobal(Concatenation("temp_",String(deg),"_",String(lev-1),"_",String(total+PrevPosList[j][n]),"_proj"));
							Vertices:=Vertices-1;
							if not IsExistingFile(fNameTemp6) then
								PrintTo(fNameTemp6, Concatenation("##This contains a list of the self-replicating groups on the rooted regular-", String(deg), " tree on level", " ", String(lev-1), "##\n\nBindGlobal(\"sr_",String(deg),"_",String(lev-1),"\",\n["));
							fi;
							if Vertices = 0 then
								AppendTo(fNameTemp6,StringFile(fNameTemp2),"\n]);");
							else
								AppendTo(fNameTemp6,StringFile(fNameTemp2),",\n");
							fi;
							PrintTo(fNameTemp5,EnString(j, o, sortedlist, total, unsortedlist1, unsortedlist2, n, p, I, M, N, Identicals, PrevPosList, Vertices));
							if reEntry then
								reEntry:=false;
								initialo:=1;
							fi;
						fi;
						if reEntry then
							reEntry:=false;
							initialo:=1;
						fi;
						n:=n+1;
					od;
				od;
			od;
		fi;
	fi;
	AppendTo(fNameTemp4,"\n]);");
	
	# x.x. Print all group information to final sr_deg_lev.grp file, remove all associated temporary files, and unbind all residual variables.
	PrintTo(fName,StringFile(fNameTemp4));
	RemoveFile(fNameTemp);
	RemoveFile(fNameTemp3);
	RemoveFile(fNameTemp4);
	RemoveFile(fNameTemp5);
	if reEntrychecker and lev>2 then
		Unleash("varArg1", "varArg2", "varArg3", "varArg4", "varArg5", "varArg6", "varArg7", "varArg8", "varArg9", "varArg10", "varArg11", "varArg12", "varArg13", "varArg14");
	elif reEntrychecker and lev=2 then
		Unleash("varArg1", "varArg2", "varArg3", "varArg4", "varArg5", "varArg6", "varArg7", "varArg8", "varArg9", "varArg10");
	elif reEntrychecker and lev=1 then
		Unleash("varArg1");
	fi;
	if lev>1 then
		PrintTo(fName2,StringFile(fNameTemp6));
		if tempfileexist then
			RemoveFile(tempFile);
		fi;
		RemoveFile(fNameTemp2);
		RemoveFile(fNameTemp6);
	fi;
fi;
return;
end);

InstallGlobalFunction(EnString, function(arg)
local Superstring, i;

for i in [1..Length(arg)] do
	if i=1 then
		Superstring:=Concatenation("varArg",String(i),":=",String(arg[i]),";");
	else
		Superstring:=Concatenation(Superstring,"\nvarArg",String(i),":=",String(arg[i]),";");
	fi;
od;

return Superstring;
end);

InstallGlobalFunction(Unleash, function(arg)
local k;

for k in [1..Length(arg)] do
	UnbindGlobal(arg[k]);
od;
end);